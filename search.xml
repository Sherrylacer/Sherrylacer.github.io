<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/2023/01/28/DFS/"/>
      <url>/2023/01/28/DFS/</url>
      
        <content type="html"><![CDATA[<h1 id="DFS"><a href="#DFS" class="headerlink" title="DFS"></a>DFS</h1><p>DFS(深度优先搜索)是一种图论算法，它通过深度优先的顺序遍历图中的所有节点。DFS算法从一个起始节点开始，不断沿着边往下搜索，直到遇到终止节点或无法继续搜索为止。</p><p>DFS算法的实现可以使用递归或使用栈来实现。递归实现中，每个节点会被搜索一次，并且在搜索完之后会被弹出。而使用栈来实现时，每个节点会被压入栈中，直到所有的节点都被搜索完。</p><p>DFS算法常用于下面的场景：</p><ol><li>求图中的连通块</li><li>检测图中是否有环</li><li>求图中的桥</li><li>求图的生成树</li><li>求图的拓扑排序</li><li>求两点之间的路径</li></ol><p>在DFS算法中，可能会出现搜索过程中无用结点的情况，这些无用结点会增加搜索时间复杂度，降低算法效率。这就是剪枝技术的用处。</p><p>剪枝技术通过在搜索过程中，对某些结点进行剪枝，减少不必要的搜索，提高算法的效率。</p><p>下面列举常见的几种剪枝技巧：</p><ol><li>回溯法剪枝：在搜索过程中，记录当前结点已经搜索过的结点，遇到已经搜索过的结点时直接返回，不再进行搜索，可以使用哈希表或者数组来维护已经搜索过的结点。</li><li>剪枝法剪枝：在搜索过程中，对某些结点进行剪枝，减少不必要的搜索，例如，在8-数码问题中，可以根据每个数字在未来的可能性进行剪枝。</li><li>深度限制剪枝：在搜索过程中，设置搜索深度的限制，当搜索深度超过限制时直接返回，一般来说，深度限制应该在问题的解的最小深度和最大深度之间。</li><li>估价函数剪枝：在搜索过程中，使用估价函数对当前结点进行估价，当估价值较大时直接返回。</li></ol><h2 id="例子：深度优先搜索迷宫"><a href="#例子：深度优先搜索迷宫" class="headerlink" title="例子：深度优先搜索迷宫"></a>例子：深度优先搜索迷宫</h2><p>我们有一个迷宫，其中起点为 (0,0)，终点为 (n-1,n-1)。我们需要使用DFS算法找到一条从起点到终点的路径。</p><p>首先，我们需要定义一个二维数组来存储迷宫地图，其中0表示可以通过的点，1表示不能通过的点。接着，我们需要定义一个栈来存储当前搜索的路径。</p><p>在DFS算法执行过程中，我们首先将起点入栈，并将起点标记为已访问。然后，每次从栈顶取出一个点，并在上下左右四个方向上搜索下一个点。如果找到了终点，则DFS算法结束；否则，继续寻找下一个点。</p><pre><code>// define the stack to store the pathstack&lt;pair&lt;int, int&gt;&gt; path;// define the 2D array to store the mazeint maze[N][N];// define the visited array to store the visited nodebool visited[N][N];bool DFS(int x, int y) &#123;    // if we find the destination    if (x == n - 1 &amp;&amp; y == n - 1) &#123;        return true;    &#125;</code></pre><pre><code>// mark the current point as visitedvisited[x][y] = true;// push the current point into the stackpath.push(&#123;x, y&#125;);// check the right pointif (y + 1 &lt; n &amp;&amp; !visited[x][y + 1] &amp;&amp; !maze[x][y + 1]) &#123;    if (DFS(x, y + 1)) &#123;        return true;    &#125;&#125;// check the down pointif (x + 1 &lt; n &amp;&amp;!visited[x + 1][y] &amp;&amp; !maze[x + 1][y]) &#123;if (DFS(x + 1, y)) &#123;return true;&#125;&#125;// check the left pointif (y - 1 &gt;= 0 &amp;&amp; !visited[x][y - 1] &amp;&amp; !maze[x][y - 1]) &#123;    if (DFS(x, y - 1)) &#123;        return true;    &#125;&#125;// check the up pointif (x - 1 &gt;= 0 &amp;&amp; !visited[x - 1][y] &amp;&amp; !maze[x - 1][y]) &#123;    if (DFS(x - 1, y)) &#123;        return true;    &#125;&#125;// if we can&#39;t find the path, pop the current point from the stackpath.pop();return false;</code></pre><p>在这个例子中，我们使用栈来存储当前搜索的路径，并在找到终点时返回 true。如果找不到终点，则返回 false。如果找不到终点，这个点也会被从栈中弹出。</p><p>这是一个简单的DFS算法的实现，但是在实际应用中，它可能会搜索到非常多的点，导致算法效率低下。因此，我们需要使用剪枝技巧来优化DFS算法。</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/2023/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/2023/01/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><p>// head存储链表头，e[]存储节点的值，ne[]存储节点的next指针，idx表示当前用到了哪个节点<br>int head, e[N], ne[N], idx;</p><p>// 初始化<br>void init()<br>{<br>    head = -1;<br>    idx = 0;<br>}</p><p>// 在链表头插入一个数a<br>void insert(int a)<br>{<br>    e[idx] = a, ne[idx] = head, head = idx ++ ;<br>}</p><p>// 将头结点删除，需要保证头结点存在<br>void remove()<br>{<br>    head = ne[head];<br>}<br>双链表<br>// e[]表示节点的值，l[]表示节点的左指针，r[]表示节点的右指针，idx表示当前用到了哪个节点<br>int e[N], l[N], r[N], idx;</p><p>// 初始化<br>void init()<br>{<br>    //0是左端点，1是右端点<br>    r[0] = 1, l[1] = 0;<br>    idx = 2;<br>}</p><p>// 在节点a的右边插入一个数x<br>void insert(int a, int x)<br>{<br>    e[idx] = x;<br>    l[idx] = a, r[idx] = r[a];<br>    l[r[a]] = idx, r[a] = idx ++ ;<br>}</p><p>// 删除节点a<br>void remove(int a)<br>{<br>    l[r[a]] = l[a];<br>    r[l[a]] = r[a];<br>}<br>栈<br>// tt表示栈顶<br>int stk[N], tt = 0;</p><p>// 向栈顶插入一个数<br>stk[ ++ tt] = x;</p><p>// 从栈顶弹出一个数<br>tt – ;</p><p>// 栈顶的值<br>stk[tt];</p><p>// 判断栈是否为空<br>if (tt &gt; 0)<br>{</p><p>}<br>队列</p><ol><li>普通队列：<br>// hh 表示队头，tt表示队尾<br>int q[N], hh = 0, tt = -1;</li></ol><p>// 向队尾插入一个数<br>q[ ++ tt] = x;</p><p>// 从队头弹出一个数<br>hh ++ ;</p><p>// 队头的值<br>q[hh];</p><p>// 判断队列是否为空<br>if (hh &lt;= tt)<br>{</p><p>}<br>2. 循环队列<br>// hh 表示队头，tt表示队尾的后一个位置<br>int q[N], hh = 0, tt = 0;</p><p>// 向队尾插入一个数<br>q[tt ++ ] = x;<br>if (tt == N) tt = 0;</p><p>// 从队头弹出一个数<br>hh ++ ;<br>if (hh == N) hh = 0;</p><p>// 队头的值<br>q[hh];</p><p>// 判断队列是否为空<br>if (hh != tt)<br>{</p><p>}<br>单调栈<br>常见模型：找出每个数左边离它最近的比它大/小的数<br>int tt = 0;<br>for (int i = 1; i &lt;= n; i ++ )<br>{<br>    while (tt &amp;&amp; check(stk[tt], i)) tt – ;<br>    stk[ ++ tt] = i;<br>}</p><h2 id="单调队列"><a href="#单调队列" class="headerlink" title="单调队列"></a>单调队列</h2><p>常见模型：找出滑动窗口中的最大值/最小值<br>int hh = 0, tt = -1;<br>for (int i = 0; i &lt; n; i ++ )<br>{<br>    while (hh &lt;= tt &amp;&amp; check_out(q[hh])) hh ++ ;  // 判断队头是否滑出窗口<br>    while (hh &lt;= tt &amp;&amp; check(q[tt], i)) tt – ;<br>    q[ ++ tt] = i;<br>}<br>KMP<br>求Next数组：<br>// s[]是模式串，p[]是模板串, n是s的长度，m是p的长度<br>for (int i = 2, j = 0; i &lt;= m; i ++ )<br>{<br>    while (j &amp;&amp; p[i] != p[j + 1]) j = ne[j];<br>    if (p[i] == p[j + 1]) j ++ ;<br>    ne[i] = j;<br>}</p><p>// 匹配<br>for (int i = 1, j = 0; i &lt;= n; i ++ )<br>{<br>    while (j &amp;&amp; s[i] != p[j + 1]) j = ne[j];<br>    if (s[i] == p[j + 1]) j ++ ;<br>    if (j == m)<br>    {<br>        j = ne[j];<br>        // 匹配成功后的逻辑<br>    }<br>}<br>Trie树<br>int son[N][26], cnt[N], idx;<br>// 0号点既是根节点，又是空节点<br>// son[][]存储树中每个节点的子节点<br>// cnt[]存储以每个节点结尾的单词数量</p><p>// 插入一个字符串<br>void insert(char *str)<br>{<br>    int p = 0;<br>    for (int i = 0; str[i]; i ++ )<br>    {<br>        int u = str[i] - ‘a’;<br>        if (!son[p][u]) son[p][u] = ++ idx;<br>        p = son[p][u];<br>    }<br>    cnt[p] ++ ;<br>}</p><p>// 查询字符串出现的次数<br>int query(char *str)<br>{<br>    int p = 0;<br>    for (int i = 0; str[i]; i ++ )<br>    {<br>        int u = str[i] - ‘a’;<br>        if (!son[p][u]) return 0;<br>        p = son[p][u];<br>    }<br>    return cnt[p];<br>}</p><h3 id="并查集"><a href="#并查集" class="headerlink" title="并查集"></a>并查集</h3><p>(1)朴素并查集：</p><pre><code>int p[N]; //存储每个点的祖宗节点// 返回x的祖宗节点int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    return p[x];&#125;// 初始化，假定节点编号是1~nfor (int i = 1; i &lt;= n; i ++ ) p[i] = i;// 合并a和b所在的两个集合：p[find(a)] = find(b);</code></pre><p>(2)维护size的并查集：</p><pre><code>int p[N], size[N];//p[]存储每个点的祖宗节点, size[]只有祖宗节点的有意义，表示祖宗节点所在集合中的点的数量// 返回x的祖宗节点int find(int x)&#123;    if (p[x] != x) p[x] = find(p[x]);    return p[x];&#125;// 初始化，假定节点编号是1~nfor (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;    size[i] = 1;&#125;// 合并a和b所在的两个集合：p[find(a)] = find(b);size[b] += size[a];</code></pre><p>(3)维护到祖宗节点距离的并查集：</p><pre><code>int p[N], d[N];//p[]存储每个点的祖宗节点, d[x]存储x到p[x]的距离// 返回x的祖宗节点int find(int x)&#123;    if (p[x] != x)    &#123;        int u = find(p[x]);        d[x] += d[p[x]];        p[x] = u;    &#125;    return p[x];&#125;// 初始化，假定节点编号是1~nfor (int i = 1; i &lt;= n; i ++ )&#123;    p[i] = i;    d[I] = 0;&#125;// 合并a和b所在的两个集合：p[find(a)] = find(b);d[find(a)] = distance; // 根据具体问题，初始化find(a)的偏移量</code></pre><p>堆<br>// h[N]存储堆中的值, h[1]是堆顶，x的左儿子是2x, 右儿子是2x + 1<br>// ph[k]存储第k个插入的点在堆中的位置<br>// hp[k]存储堆中下标是k的点是第几个插入的<br>int h[N], ph[N], hp[N], size;</p><p>// 交换两个点，及其映射关系<br>void heap_swap(int a, int b)<br>{<br>    swap(ph[hp[a]],ph[hp[b]]);<br>    swap(hp[a], hp[b]);<br>    swap(h[a], h[b]);<br>}</p><p>void down(int u)<br>{<br>    int t = u;<br>    if (u * 2 &lt;= size &amp;&amp; h[u * 2] &lt; h[t]) t = u * 2;<br>    if (u * 2 + 1 &lt;= size &amp;&amp; h[u * 2 + 1] &lt; h[t]) t = u * 2 + 1;<br>    if (u != t)<br>    {<br>        heap_swap(u, t);<br>        down(t);<br>    }<br>}</p><p>void up(int u)<br>{<br>    while (u / 2 &amp;&amp; h[u] &lt; h[u / 2])<br>    {<br>        heap_swap(u, u / 2);<br>        u &gt;&gt;= 1;<br>    }<br>}</p><p>// O(n)建堆<br>for (int i = n / 2; i; i – ) down(i);<br>一般哈希<br>(1) 拉链法<br>    int h[N], e[N], ne[N], idx;</p><pre><code>// 向哈希表中插入一个数void insert(int x)&#123;    int k = (x % N + N) % N;    e[idx] = x;    ne[idx] = h[k];    h[k] = idx ++ ;&#125;// 在哈希表中查询某个数是否存在bool find(int x)&#123;    int k = (x % N + N) % N;    for (int i = h[k]; i != -1; i = ne[i])        if (e[i] == x)            return true;    return false;&#125;</code></pre><p>(2) 开放寻址法<br>    int h[N];</p><pre><code>// 如果x在哈希表中，返回x的下标；如果x不在哈希表中，返回x应该插入的位置int find(int x)&#123;    int t = (x % N + N) % N;    while (h[t] != null &amp;&amp; h[t] != x)    &#123;        t ++ ;        if (t == N) t = 0;    &#125;    return t;&#125;</code></pre><p>字符串哈希<br>核心思想：将字符串看成P进制数，P的经验值是131或13331，取这两个值的冲突概率低<br>小技巧：取模的数用2^64，这样直接用unsigned long long存储，溢出的结果就是取模的结果</p><p>typedef unsigned long long ULL;<br>ULL h[N], p[N]; // h[k]存储字符串前k个字母的哈希值, p[k]存储 P^k mod 2^64</p><p>// 初始化<br>p[0] = 1;<br>for (int i = 1; i &lt;= n; i ++ )<br>{<br>    h[i] = h[i - 1] * P + str[i];<br>    p[i] = p[i - 1] * P;<br>}</p><p>// 计算子串 str[l ~ r] 的哈希值<br>ULL get(int l, int r)<br>{<br>    return h[r] - h[l - 1] * p[r - l + 1];<br>}<br>C++ STL简介<br>vector, 变长数组，倍增的思想<br>    size()  返回元素个数<br>    empty()  返回是否为空<br>    clear()  清空<br>    front()/back()<br>    push_back()/pop_back()<br>    begin()/end()<br>    []<br>    支持比较运算，按字典序</p><p>pair&lt;int, int&gt;<br>    first, 第一个元素<br>    second, 第二个元素<br>    支持比较运算，以first为第一关键字，以second为第二关键字（字典序）</p><p>string，字符串<br>    size()/length()  返回字符串长度<br>    empty()<br>    clear()<br>    substr(起始下标，(子串长度))  返回子串<br>    c_str()  返回字符串所在字符数组的起始地址</p><p>queue, 队列<br>    size()<br>    empty()<br>    push()  向队尾插入一个元素<br>    front()  返回队头元素<br>    back()  返回队尾元素<br>    pop()  弹出队头元素</p><p>priority_queue, 优先队列，默认是大根堆<br>    push()  插入一个元素<br>    top()  返回堆顶元素<br>    pop()  弹出堆顶元素<br>    定义成小根堆的方式：priority_queue&lt;int, vector<int>, greater<int>&gt; q;</p><p>stack, 栈<br>    size()<br>    empty()<br>    push()  向栈顶插入一个元素<br>    top()  返回栈顶元素<br>    pop()  弹出栈顶元素</p><p>deque, 双端队列<br>    size()<br>    empty()<br>    clear()<br>    front()/back()<br>    push_back()/pop_back()<br>    push_front()/pop_front()<br>    begin()/end()<br>    []</p><p>set, map, multiset, multimap, 基于平衡二叉树（红黑树），动态维护有序序列<br>    size()<br>    empty()<br>    clear()<br>    begin()/end()<br>    ++, – 返回前驱和后继，时间复杂度 O(logn)</p><pre><code>set/multiset    insert()  插入一个数    find()  查找一个数    count()  返回某一个数的个数    erase()        (1) 输入是一个数x，删除所有x   O(k + logn)        (2) 输入一个迭代器，删除这个迭代器    lower_bound()/upper_bound()        lower_bound(x)  返回大于等于x的最小的数的迭代器        upper_bound(x)  返回大于x的最小的数的迭代器map/multimap    insert()  插入的数是一个pair    erase()  输入的参数是pair或者迭代器    find()    []  注意multimap不支持此操作。 时间复杂度是 O(logn)    lower_bound()/upper_bound()</code></pre><p>unordered_set, unordered_map, unordered_multiset, unordered_multimap, 哈希表<br>    和上面类似，增删改查的时间复杂度是 O(1)<br>    不支持 lower_bound()/upper_bound()， 迭代器的++，–</p><p>bitset, 圧位<br>    bitset&lt;10000&gt; s;<br>    ~, &amp;, |, ^<br>    &gt;&gt;, &lt;&lt;<br>    ==, !=<br>    []</p><pre><code>count()  返回有多少个1any()  判断是否至少有一个1none()  判断是否全为0set()  把所有位置成1set(k, v)  将第k位变成vreset()  把所有位变成0flip()  等价于~flip(k) 把第k位取反  </code></pre><p><img src="https://p3-bcy-sign.bcyimg.com/banciyuan/d00ef9e05e234f229d8f9ae4a286408d~tplv-banciyuan-w650.image?x-expires=1673582690&x-signature=FHBJY7j98nJQM8DiJCdAoVGWn2w="></p>]]></content>
      
      
      
        <tags>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
